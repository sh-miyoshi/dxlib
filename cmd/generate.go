package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

var (
	errInvalidLine = errors.New("Invalid input line")
	errInvalidArg  = errors.New("Invalid argument")
)

type dxFunc struct {
	Name     string
	Response string
	GoArgs   string
	PArgs    string
	ProcName string
}

type argument struct {
	Name   string
	CType  string
	GoType string
}

func validType(typ string) bool {
	valids := []string{"int", "string"}
	for _, valid := range valids {
		if valid == typ {
			return true
		}
	}
	return false
}

func parseArg(argStr string) ([]argument, error) {
	res := []argument{}
	for _, arg := range strings.Split(argStr, ",") {
		arg = strings.TrimSpace(arg)

		// TODO
		// v := strings.Split(strings.TrimSpace(arg), " ")
		// if len(v) != 2 {
		// 	return nil, errInvalidArg
		// }
		// typ :=v[1]

		// res = append(res, argument{Name: v[0], Type: typ})
	}

	return res, nil
}

func parse(line string) (*dxFunc, error) {
	if !strings.HasPrefix(line, "//dxlib") {
		return nil, nil
	}

	res := dxFunc{}
	raw := strings.TrimPrefix(line, "//dxlib ")

	// valid format
	//dxlib func <FuncName>(<arg1> interface{}, <arg2> ...) <response> "dx_<FuncName>"
	v1 := strings.Split(raw, "(")
	if len(v1) != 2 {
		return nil, errInvalidLine
	}
	res.Name = strings.TrimPrefix(v1[0], "func ")

	v2 := strings.Split(v1[1], ")")
	if len(v2) != 2 {
		return nil, errInvalidLine
	}
	args, err := parseArg(v2[0])
	if err != nil {
		return nil, err
	}
	for _, arg := range args {
		res.GoArgs += arg.Name + " " + arg.GoType + ", "
		res.PArgs += "p" + arg.GoType + "(" + arg.Name + "), "
	}
	res.GoArgs = strings.TrimSuffix(res.GoArgs, ", ")
	res.PArgs = strings.TrimSuffix(res.PArgs, ", ")

	v3 := strings.Split(strings.TrimPrefix(v2[1], " "), " ")
	if len(v3) != 2 {
		return nil, errInvalidLine
	}
	res.Response = v3[0]
	res.ProcName = strings.Trim(v3[1], "\"")

	return &res, nil
}

func generate(w io.Writer, packageName string, funcs []dxFunc) {
	procs := []string{}
	for _, f := range funcs {
		procs = append(procs, f.ProcName)
	}

	data := map[string]interface{}{
		"Package":   packageName,
		"Procs":     procs,
		"Functions": funcs,
	}

	t := template.Must(template.New("main").Parse(outTemplate))
	t.Execute(w, data)
}

func main() {
	var input, output string
	flag.StringVar(&input, "input", "", "input file name")
	flag.StringVar(&input, "i", "", "input file name")
	flag.StringVar(&output, "output", "", "output file name")
	flag.StringVar(&output, "o", "", "output file name")

	flag.Parse()

	if input == "" || output == "" {
		fmt.Printf("Please set input and output\n")
		os.Exit(1)
	}

	fp, err := os.Open(input)
	if err != nil {
		fmt.Printf("Failed to open file %s: %v\n", input, err)
		os.Exit(1)
	}
	defer fp.Close()

	data := []dxFunc{}
	packageName := ""
	scanner := bufio.NewScanner(fp)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "package") {
			packageName = strings.Split(line, " ")[1]
			continue
		}
		d, err := parse(line)
		if err != nil {
			fmt.Printf("Failed to parse file: %v\n", err)
			os.Exit(1)
		}
		if d != nil {
			data = append(data, *d)
		}
	}

	var buf bytes.Buffer
	generate(&buf, packageName, data)
	ioutil.WriteFile(output, buf.Bytes(), 0644)
}

const outTemplate = `
// Code generated by 'go generate'; DO NOT EDIT.

package {{ .Package }}

import (
	"syscall"
)

var (
	mod = syscall.NewLazyDLL("DxLib.dll")

	{{ range .Procs -}}
	{{.}} = mod.NewProc("{{.}}")
	{{ end }}
)

{{ range $i, $func := .Functions }}
func {{ $func.Name }}({{ $func.GoArgs }}) {{ $func.Response }} {
	r, _, err := {{ $func.ProcName }}.Call({{ $func.PArgs }})
	if err != nil {
		panic(err)
	}
	return int(r)
}
{{ end }}
`
