package output

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"text/template"
	"unicode"

	"github.com/sh-miyoshi/dxlib/cmd/generate/parse"
)

func Output(filePath string, data parse.Data) {
	var buf bytes.Buffer
	writeHeader(&buf, data.PackageName)
	writeOpt(&buf, data.Options)
	writeFunc(&buf, data.Funcs, data.ExtFuncs, data.Options)
	writeExtFunc(&buf)
	writePFuncs(&buf)
	ioutil.WriteFile(filePath, buf.Bytes(), 0644)
}

func writeHeader(w io.Writer, packageName string) {
	const outTemplate = `
// Code generated by 'go generate'; DO NOT EDIT.

package {{ .Package }}

import (
	"fmt"
	"syscall"
	"unsafe"
	"math"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)
`
	data := map[string]interface{}{
		"Package": packageName,
	}

	t := template.Must(template.New("main").Parse(outTemplate))
	t.Execute(w, data)
}

func writeOpt(w io.Writer, opts []parse.Option) {
	const outTemplate = `
{{ range $i, $opt := .Options }}
type {{ $opt.FuncName }}Option struct {
	{{ range $j, $arg := $opt.Args -}}
	{{ $arg.Name }} *{{ $arg.GoType }}
	{{ end -}}
}
{{ end }}
`

	viewOpts := []parse.Option{}
	for _, opt := range opts {
		if len(opt.Args) == 0 {
			continue
		}
		d := parse.Option{FuncName: opt.FuncName}
		for _, arg := range opt.Args {
			d.Args = append(d.Args, parse.Argument{
				Name:    capitalize(arg.Name),
				GoType:  arg.GoType,
				Default: arg.Default,
			})
		}
		viewOpts = append(viewOpts, d)
	}
	data := map[string]interface{}{
		"Options": viewOpts,
	}

	t := template.Must(template.New("main").Parse(outTemplate))
	t.Execute(w, data)
}

func writeFunc(w io.Writer, funcs, extra []parse.DxFunc, opts []parse.Option) {
	const outTemplate = `
var (
	{{ range .Procs -}}
	dx_{{.}} *syscall.LazyProc
	{{ end }}
)

// Init method set procs from dllFile.
// This method must be called at first.
func Init(dllFile string) {
	mod := syscall.NewLazyDLL(dllFile)

	{{ range .Procs -}}
	dx_{{.}} = mod.NewProc("dx_{{.}}")
	{{ end }}
}

{{ range $i, $func := .Functions }}
{{ $func.Comment -}}
func {{ $func.Name }}({{ $func.GoArgs }}) {{ $func.Response }} {
	if dx_{{ $func.Name }} == nil {
		panic("Please call dxlib.Init() at first")
	}

	{{ optVarShow $func.Name }}

	res, _, _ := dx_{{ $func.Name }}.Call({{ $func.PArgs }})
	return  {{ $func.Response }}(res)
}
{{ end }}
`

	// todo(デフォルト引数の処理をtemplateに追加)
	optVarShow := func(funcName string) string {
		for _, opt := range opts {
			if opt.FuncName == funcName {
				res := ""
				for _, arg := range opt.Args {
					res += fmt.Sprintf("%s := %s(%s)\n", arg.Name, arg.GoType, arg.Default)
					res += fmt.Sprintf("if len(opt) > 0 && opt[0].%s != nil {\n", capitalize(arg.Name))
					res += fmt.Sprintf("%s = *opt[0].%s\n", arg.Name, capitalize(arg.Name))
					res += "}\n"
				}
				return res
			}
		}
		return ""
	}

	procs := []string{}
	for _, f := range funcs {
		procs = append(procs, f.Name)
	}
	for _, f := range extra {
		procs = append(procs, f.Name)
	}

	data := map[string]interface{}{
		"Procs":     procs,
		"Functions": funcs,
	}

	funcMap := map[string]interface{}{
		"optVarShow": optVarShow,
	}

	t := template.Must(template.New("main").Funcs(funcMap).Parse(outTemplate))
	t.Execute(w, data)
}

func writeExtFunc(w io.Writer) {
	io.WriteString(w, `
func DrawFormatString(x int32, y int32, color uint32, format string, a ...interface{}) int32 {
	str := fmt.Sprintf(format, a...)
	return DrawString(x, y, str, color)
}

func DrawFormatStringToHandle(x int32, y int32, color uint32, fontHandle int32, format string, a ...interface{}) int32 {
	str := fmt.Sprintf(format, a...)
	return DrawStringToHandle(x, y, str, color, fontHandle)
}

func ClearDrawScreen() int32 {
	temp := RECT{
		left: -1,
		top: -1,
		right: -1,
		bottom: -1,
	}

	res, _, _ := dx_ClearDrawScreen.Call(uintptr(unsafe.Pointer(&temp)))
	return int32(res)
}

func AddFontFile(fontFilePath string) *int32 {
	if dx_AddFontFile == nil {
		panic("Please call dxlib.Init() at first")
	}

	res, _, _ := dx_AddFontFile.Call(pstring(fontFilePath))
	if res == 0 {
		return nil
	}
	return (*int32)(unsafe.Pointer(&res))
}
`)
}

func writePFuncs(w io.Writer) {
	io.WriteString(w, `
func ppint32(i *int32) uintptr {
	return uintptr(unsafe.Pointer(i))
}

func pint32(i int32) uintptr {
	return uintptr(i)
}

func puint32(ui uint32) uintptr {
	return uintptr(ui)
}

func pfloat32(f float32) uintptr {
	return uintptr(math.Float32bits(f))
}

func pfloat64(f float64) uintptr {
	return uintptr(math.Float64bits(f))
}

func pint64(i int64) uintptr {
	return uintptr(i)
}

func parraybyte(b []byte) uintptr {
	return uintptr(unsafe.Pointer(&b[0]))
}

func parrayint32(i []int32) uintptr {
	return uintptr(unsafe.Pointer(&i[0]))
}

func pstring(str string) uintptr {
	sjisStr, _, err := transform.String(japanese.ShiftJIS.NewEncoder(), str)
	if err != nil {
		panic(err)
	}
	pbyte, err := syscall.BytePtrFromString(sjisStr)
	if err != nil {
		panic(err)
	}
	return uintptr(unsafe.Pointer(pbyte))
}

func pVECTOR(vec VECTOR) uintptr {
	return uintptr(unsafe.Pointer(&vec))
}
`)
}

func capitalize(word string) string {
	tmp := []byte(word)
	tmp[0] = byte(unicode.ToUpper(rune(word[0])))
	return string(tmp)
}
