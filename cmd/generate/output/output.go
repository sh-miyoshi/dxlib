package output

import (
	"bytes"
	"io"
	"io/ioutil"
	"text/template"

	"github.com/sh-miyoshi/dxlib/cmd/generate/parse"
)

func Output(filePath string, data parse.Data) {
	var buf bytes.Buffer
	writeMain(&buf, data.PackageName, data.Funcs, data.ExtFuncs)
	writeExtFunc(&buf)
	writePFuncs(&buf)
	ioutil.WriteFile(filePath, buf.Bytes(), 0644)
}

func writeMain(w io.Writer, packageName string, funcs, extra []parse.DxFunc) {
	procs := []string{}
	for _, f := range funcs {
		procs = append(procs, f.Name)
	}
	for _, f := range extra {
		procs = append(procs, f.Name)
	}

	data := map[string]interface{}{
		"Package":   packageName,
		"Procs":     procs,
		"Functions": funcs,
	}

	t := template.Must(template.New("main").Parse(outTemplate))
	t.Execute(w, data)
}

func writeExtFunc(w io.Writer) {
	io.WriteString(w, `
func DrawFormatString(x int32, y int32, color uint32, format string, a ...interface{}) int32 {
	str := fmt.Sprintf(format, a...)
	return DrawString(x, y, str, color, 0)
}

func DrawFormatStringToHandle(x int32, y int32, color uint32, fontHandle int32, format string, a ...interface{}) int32 {
	str := fmt.Sprintf(format, a...)
	return DrawStringToHandle(x, y, str, color, fontHandle, 0, FALSE)
}

func ClearDrawScreen() int32 {
	temp := RECT{
		left: -1,
		top: -1,
		right: -1,
		bottom: -1,
	}

	res, _, _ := dx_ClearDrawScreen.Call(uintptr(unsafe.Pointer(&temp)))
	return int32(res)
}
`)
}

func writePFuncs(w io.Writer) {
	io.WriteString(w, `
func ppint32(i *int32) uintptr {
	return uintptr(unsafe.Pointer(i))
}

func pint32(i int32) uintptr {
	return uintptr(i)
}

func puint32(ui uint32) uintptr {
	return uintptr(ui)
}

func pfloat32(f float32) uintptr {
	return uintptr(math.Float32bits(f))
}

func pfloat64(f float64) uintptr {
	return uintptr(math.Float64bits(f))
}

func pint64(i int64) uintptr {
	return uintptr(i)
}

func parraybyte(b []byte) uintptr {
	return uintptr(unsafe.Pointer(&b[0]))
}

func parrayint32(i []int32) uintptr {
	return uintptr(unsafe.Pointer(&i[0]))
}

func pstring(str string) uintptr {
	sjisStr, _, err := transform.String(japanese.ShiftJIS.NewEncoder(), str)
	if err != nil {
		panic(err)
	}
	pbyte, err := syscall.BytePtrFromString(sjisStr)
	if err != nil {
		panic(err)
	}
	return uintptr(unsafe.Pointer(pbyte))
}
`)
}

const outTemplate = `
// Code generated by 'go generate'; DO NOT EDIT.

package {{ .Package }}

import (
	"fmt"
	"syscall"
	"unsafe"
	"math"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

var (
	{{ range .Procs -}}
	dx_{{.}} *syscall.LazyProc
	{{ end }}
)

// Init method set procs from dllFile.
// This method must be called at first.
func Init(dllFile string) {
	mod := syscall.NewLazyDLL(dllFile)

	{{ range .Procs -}}
	dx_{{.}} = mod.NewProc("dx_{{.}}")
	{{ end }}
}

{{ range $i, $func := .Functions }}
{{ $func.Comment -}}
func {{ $func.Name }}({{ $func.GoArgs }}) {{ $func.Response }} {
	if dx_{{ $func.Name }} == nil {
		panic("Please call dxlib.Init() at first")
	}

	res, _, _ := dx_{{ $func.Name }}.Call({{ $func.PArgs }})
	return  {{ $func.Response }}(res)
}
{{ end }}
`
